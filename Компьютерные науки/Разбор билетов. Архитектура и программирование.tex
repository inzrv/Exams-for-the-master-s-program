\documentclass[12pt]{article}
\usepackage[utf8]{inputenc} % Включаем поддержку UTF8
\usepackage[T2A]{fontenc}
\usepackage[russian]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{verbatim}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{caption}
\usepackage{graphicx}%Вставка картинок правильная
\usepackage{float}%"Плавающие" картинки
\usepackage{wrapfig}%Обтекание фигур (таблиц, картинок и прочего)

\begin{document}
\textbf{Вопросы. Архитектура и программирование.} \\


\noindent\rule{\textwidth}{1pt}
\textbf{(SE)} Архитектура компьютера: архитектура фон Неймана, гарвардская архитектура.

\noindent\rule{\textwidth}{1pt}


В 1940-х годах в процессе работы над первыми электронными вычислительными машинами Джон фон Нейман и его коллеги определили ряд принципов построения вычислительных машин.

\textbf{Принципы фон Неймана:}

\begin{enumerate}
	\item \textit{Принцип однородности памяти}
	
	Команды и данные хранятся в одной и той же памяти и внешне в памяти неразличимы. Распознать их можно только по способу использования; то есть одно и то же значение в ячейке памяти может использоваться и как данные, и как команда, и как адрес в зависимости лишь от способа обращения к нему. Это позволяет производить над командами те же операции, что и над числами, и, соответственно, открывает ряд возможностей.  Так, например, команды одной программы могут быть получены как результат исполнения другой программы. Эта возможность лежит в основе трансляции --- перевода текста программы с языка высокого уровня на язык конкретной вычислительной машины.
	
	\item \textit{Принцип адресности}
	
	Структурно основная память состоит из пронумерованных ячеек, причём процессору в произвольный момент доступна любая ячейка. Двоичные коды команд и данных разделяются на единицы информации, называемые словами, и хранятся в ячейках памяти, а для доступа к ним используются номера соответствующих ячеек --- адреса.
	
	\item \textit{Принцип программного управления}
	
	
Все вычисления, предусмотренные алгоритмом решения задачи, должны быть представлены в виде программы, состоящей из последовательности управляющих слов --- команд. Каждая команда предписывает некоторую операцию из набора операций, реализуемых вычислительной машиной. Команды программы хранятся в последовательных ячейках памяти вычислительной машины и выполняются в естественной последовательности, то есть в порядке их положения в программе. При необходимости, с помощью специальных команд, эта последовательность может быть изменена. Решение об изменении порядка выполнения команд программы принимается либо на основании анализа результатов предшествующих вычислений, либо безусловно.
	
\end{enumerate}

\begin{figure}
\centering
\includegraphics[width=0.6\linewidth]{neumann.png}
\caption{Архитектура фон Неймана}
\label{fig:mpr}
\end{figure}

\textbf{Узкое место архитектуры фон Неймана}

Совместное использование шины для памяти программ и памяти данных приводит к узкому месту архитектуры фон Неймана, а именно ограничению пропускной способности между процессором и памятью по сравнению с объёмом памяти. Из-за того, что память программ и память данных не могут быть доступны в одно и то же время, пропускная способность канала <<процессор-память>> и скорость работы памяти существенно ограничивают скорость работы процессора — гораздо сильнее, чем если бы программы и данные хранились в разных местах.

Данная проблема решается совершенствованием систем кэширования, что в свою очередь усложняет архитектуру систем и увеличивает риск возникновения побочных ошибок (например, проблема когерентности памяти).


\textbf{Гарвардская архитектура}

Гарвардская архитектура --- архитектура ЭВМ, разработанная в конце 1930-х годов в Гарвардском университете. Отличительными признаками данной архитектуры являются:

\begin{figure}
\centering
\includegraphics[width=0.6\linewidth]{har.png}
\caption{Гарвардская архитектура}
\label{fig:mpr}
\end{figure}

\begin{itemize}

\item  хранилище инструкций и хранилище данных представляют собой разные физические устройства;

\item канал инструкций и канал данных также физически разделены.
\end{itemize}

В архитектуре фон Неймана процессор в каждый момент времени может либо читать инструкцию, либо читать/записывать единицу данных из/в памяти. Оба действия одновременно происходить не могут, поскольку инструкции и данные используют один и тот же поток (шину).

В компьютере с использованием гарвардской архитектуры процессор может считывать очередную команду и оперировать памятью данных одновременно и без использования кэш-памяти.

Исходя из физического разделения шин команд и данных, разрядности этих шин могут различаться и физически не могут пересекаться. \\


\noindent\rule{\textwidth}{1pt}
\textbf{(SE)} Объектно-ориентированное программирование. Основные принципы.

\noindent\rule{\textwidth}{1pt}

\textbf{Объектно-ориентированное программирование} ---  методология программирования, основанная на представлении программы в виде совокупности взаимодействующих \textit{объектов}, каждый из которых является экземпляром определённого \textit{класса}, а классы образуют \textit{иерархию наследования}.


\textbf{Объект} --- это сущность, которой можно посылать сообщения и которая может на них реагировать, используя свои данные. Объект --- это экземпляр класса. Данные объекта скрыты от остальной программы.

\textbf{Класс} --- в объектно-ориентированном программировании, представляет собой шаблон для создания объектов, обеспечивающий начальные значения состояний: инициализация полей-переменных и реализация поведения функций или методов.

Объекты внутри программы взаимодействуют с помощью \textbf{сообщений}. Во многих языках программирования используется концепция <<\textit{отправка сообщений как вызов метода}>> --- объекты имеют доступные извне методы, вызовами которых и обеспечивается взаимодействие объектов. \\

\textbf{Основные принципы ООП.}
\begin{enumerate}

	\item \textbf{Абстракция}
	
	Абстракция в объектно-ориентированном программировании --- это использование только тех характеристик объекта, которые с достаточной точностью представляют его в данной системе. Основная идея состоит в том, чтобы представить объект минимальным набором полей и методов и при этом с достаточной точностью для решаемой задачи.
	
	
	\item \textbf{Инкапсуляция. Две трактовки}
	
	
	Инкапсуляция --- свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе. В общем случае в разных языках программирования термин \textit{инкапсуляция} относится к одной или обеим одновременно следующим нотациям:
	\begin{itemize}
	\item механизм языка, позволяющий ограничить доступ одних компонентов программы к другим;
	
	\item языковая конструкция, позволяющая связать данные с методами, предназначенными для обработки этих данных.
	
	\end{itemize}
	
	\item \textbf{Наследование}
	
	
	Наследование --- свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствованной функциональностью. Класс, от которого производится наследование, называется базовым, родительским или суперклассом. Новый класс --- потомком, наследником, дочерним или производным классом.
	
	\item \textbf{Полиморфизм}
	
	Полиморфизмом называется возможность единообразно обрабатывать разные типы данных. В языке C++ можно выделить следующие механизмы полиморфизма:
	
	\begin{itemize}
	\item Перегрузка функций (не обязательно ООП?). Выбор функции происходит в момент компиляции на основе типов аргументов функции, \textit{статический полиморфизм}.
	
	\item Виртуальные методы. Выбор метода происходит в момент выполнения на основе типа объекта, у которого вызывается виртуальный метод, \textit{динамический полиморфизм}.
	
	\end{itemize}
	
\end{enumerate}

\noindent\rule{\textwidth}{1pt}
\textbf{(SE)} Компиляция программ. Как устроен компилятор? Зачем нужен компилятор. Интерпретация программ.

\noindent\rule{\textwidth}{1pt}

\textbf{Определение.} \textit{Компилятор} --- это программа, которая считывает текст программы, написанной на одном языке --- исходном, и транслирует (переводит) его в эквивалентный текст на другом языке --- целевом. 

Одна из важных ролей компилятора состоит в сообщении об ошибках в исходной программе, обнаруженных в процессе трансляции.

Если целевая программа представляет собой программу на машинном коде (языке), то она может быть вызвана пользователем для обработки некоторых входных данных и получения некоторых выходных данных.

\textbf{Определение.} \textit{Интерпретация} --- процесс построчного анализа, обработки и выполнения исходного кода программы, в отличие от компиляции, где весь текст программы перед запуском анализируется и транслируется в машинный или байт-код без ее выполнения.


\begin{figure}[h]
\centering
\includegraphics[width=0.6\linewidth]{comp2.png}
\caption{Схематичное изображение принципа работы интерпретатора}
\label{fig:mpr}
\end{figure}

\textbf{Определение.} \textit{Интерпретатор} --- программа, выполняющая интерпретацию.


\begin{figure}
\centering
\includegraphics[width=1\linewidth]{comp1.png}
\caption{Схематичное изображение принципа работы компилятора и целевой программы}
\label{fig:mpr}
\end{figure}

Целевая программа на машинном языке, производимая компилятором, обычно гораздо быстрее, чем интерпретатор, получает \textbf{выходные} данные на основе входных. Однако интерпретатор обычно обладает лучшими способностями к диагностике, поскольку он выполняет исходную программу инструкция за инструкцией. При этом компилятор требует больше времени для анализа и обработки языка высокого уровня.

\textbf{Пример.} Языковой процессор Java объединяет в себе и компиляцию и интерпретацию. Исходная программа на Java может сначала компилироваться в байт-код, а затем байт-код интерпретируется виртуальной машиной. Преимущество такого подхода в том, что скомпилированный на одной машине байт-код может быть выполнен на другой.  


Перевод исходной программы в целевой машинный код происходит в несколько этапов (см. Рис. 5). \\

\begin{figure}
\centering
\includegraphics[width=0.6\linewidth]{comp3.png}
\caption{Система обработки языка}
\label{fig:mpr}
\end{figure} 


\textbf{Этап №1. Препроцессор}

Препроцессор работает с исходным текстом. Обычно он выполняет замену макросов (C/C++), удаляет комментарии, выполняет директивы, начинающиеся с символа \# (\#include, \#define, \#pragma ...).

\textbf{Этап №2. Компилятор (трансляция)}

На данном этапе происходит перевод исходного кода (программы на исходном языке) в целевой код (программу на целевом языке). Целевым языком может быть один из низкоуровневых языков: машинный код, байт-код, язык ассемблера.

\textbf{Этап №2,5. Ассемблер}
Если компилятор возвращает программу на языке ассемблера, то необходим данный этап, на котором происходит обработка языка ассемблера программой \textit{ассемблер}. Результатом данного этапа является машинный код.


\textbf{Этап №3. Компоновщик/Загрузчик (сборка, линковка)}

Большие программы компилируются по частям, поэтому после получения нескольких объектных файлов их нужно скомпоновать. Компоновщик выполняет разрешение адресов памяти, по которым код из одного файла сможет обращаться к информации из другого файла. \textit{Загрузчик} затем помещает все выполнимые объектные файлы в память для выполнения.























\newpage
\noindent\rule{\textwidth}{1pt}
\textbf{(SE)} C++: как происходит компиляция, интерпретация, выполнение.

\noindent\rule{\textwidth}{1pt}	

C++ --- компилируемый язык. Для запуска программы на С++ необходимо транслировать ее из текстовой формы, понятной для человека, в форму, понятную для машины. Этим занимается компилятор. 	


Особенности компиляции:
\begin{enumerate}
\item Нет накладных расходов при исполнении программы.
\item При компиляции можно отловить некоторые ошибки (?).
\item Программу требуется компилировать для каждой платформы отдельно.
\end{enumerate}

Подробнее о этапах компиляции программ на C++.

\textbf{Этап №1. Препроцессор}

Препроцессор работает с кодом на C++ как с текстом. Команды языка препроцессора называют \textit{директивами}, все директивы начинаются со знака \#. Директива\textbf{ \#include} позволяет подключать заголовочные файлы к файлам кода. Препроцессор просто заменяет директиву \textbf{\#include "func.h"} на содержимое файла \textbf{func.h}.
Препроцессор может выдать ошибку, если указанного файла нет или директива написана с ошибкой. При этом он ничего не знает о синтаксисе C++, то есть не будет выдавать ошибку на \textbf{intt main().} Для того, чтобы отследить работу препроцессора компилятора \textbf{g++} необходимо вызвать команду: \\ 
\textbf{g++ -E main.cpp}.

\textbf{Этап №2. Компиляция}

На вход компилятору поступает код на C++, который уже прошел обработку препроцессора. Каждый файл с кодом (\textbf{file.cpp}) компилируется отдельно и независимо от других. Эта особенность позволяет, например, перекомпилировать только файл с ошибкой. На выходе компилятора из каждого файла с кодом получается "объектный файл" --- бинарный файл со скомпилированным кодом (с расширением \textbf{.o} или \textbf{.obj}). Файл с расширением \textbf{.o} уже нельзя прочитать (см. Рис.6). Для компиляции файлов после препроцессинга можно использовать команду \\
\textbf{g++ -c main\_preprocessed.cpp}.

\begin{figure}
\centering
\includegraphics[width=0.6\linewidth]{comp4.png}
\caption{Попытка открыть объктный файл в текстовом редакторе}
\label{fig:mpr}
\end{figure} 

\textbf{Этап №3. Компоновка (линковка)}

Программа может состоять из отдельных частей. Пример: программа "Hello, World!" состоит из написанной нами части \textbf{int main() \{ \}} и частей стандартной библиотеки языка C++. Эти отдельные части называются единицами трансляции.

\textbf{Определение.} В языках программирования \textit{единица трансляции} --- максимальный блок исходного текста, который физически можно оттранслировать (преобразовать во внутреннее машинное представление; в частности, откомпилировать). 

\textit{Примечение. Раньше размер оперативной памяти компьютера не позволял содержать одновременно компилятор, текст крупной программы и результирующий код, поэтому приходилось компилировать ее по частям и собирать из откомпилированных частей исполняемый файл.}

В языках программирования C и C++ единица трансляции --- подаваемый на вход компилятора исходный текст (файл с расширением \textbf{.c} или \textbf{.cpp}) со всеми включёнными (содержимое которых вставляется препроцессором) в него файлами.

Программа, связывающая файлы с результирующим объектным кодом, называется \textit{редактором связей} или \textit{компоновщик} или \textit{линковщик}.


Итак, на этапе линковки все объектные файлы объединяются в один исполняемый (или библиотечный) файл. При этом происходит подстановка адресов функций в места их вызова. По каждому объектному файлу строится таблица всех функций, которые в нем определены. 


На этапе линковки важно, чтобы каждая функция имела уникальное имя. В C++ может быть две функции с одинаковыми именами, но разными параметрами. Для того, чтобы не путать функции с одинаковыми именами происходит искажение имен функций. Например, gcc преобразует функцию
\textbf{void foo(int, double)} в \textbf{\_Z3fooid}. Поэтому нельзя начинать имена функций и переменных с цифры.

Помимо прочего на этапе линковки происходит выставление точки входа в программу.

\textbf{Определение.} Точка входа --- это функция, вызываемая при запуске программы. По умолчанию --- это функция \textbf{main()}. 


Для того чтобы собрать объектные файлы в один исполняемый можно воспользоваться командой \\
\textbf{g++ main.o square.o -o file\_name}.


\begin{figure}[h]
\centering
\includegraphics[width=0.7\linewidth]{comp5.png}
\caption{Схема процесса компиляции программы на C++}
\label{fig:mpr}
\end{figure} 



\end{document}
